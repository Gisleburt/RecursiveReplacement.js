{"version":3,"sources":["recursive-replacement.js","recursive-replacement.ts"],"names":["RecursiveReplacement","RecursiveReplacement_1","doestStringContainReplacements","testString","delimiter","Error","parts","split","length","regexp","RegExp","result","match","getReplacementsInString","exec","push","trim","replaceInString","stringWithReplacements","replacements","getReplacementFromData","key","replacementData","module","exports"],"mappings":"AAAA,YCAA,IAAOA,uBAAP,SAAOC,GAoBH,GAAAD,GAAA,WAAA,QAAAA,MA4EA,MApEkBA,GAAAE,+BAAd,SAA6CC,EAAmBC,GAE5D,GAF4D,SAAAA,IAAAA,EAAA,SAEjC,gBAAhBD,GACP,KAAM,IAAIE,OAAM,2EAEpB,IAA0B,gBAAfD,GACP,KAAM,IAAIC,OAAM,4EAEpB,IAAIC,GAAQF,EAAUG,MAAM,IAC5B,IAAmB,GAAhBD,EAAME,OACL,KAAM,IAAIH,OAAM,uFAKpB,IAAII,GAAS,GAAIC,QAAOJ,EAAM,GAAG,SAASA,EAAM,GAAG,QAAQA,EAAM,GAAI,KACjEK,EAASR,EAAWS,MAAMH,EAC9B,SAASE,GAAUA,EAAOH,OAAS,GAUzBR,EAAAa,wBAAd,SAAsCV,EAAmBC,GAErD,GAFqD,SAAAA,IAAAA,EAAA,SAE1B,gBAAhBD,GACP,KAAM,IAAIE,OAAM,oEAEpB,IAA0B,gBAAfD,GACP,KAAM,IAAIC,OAAM,qEAEpB,IAAIC,GAAQF,EAAUG,MAAM,IAC5B,IAAmB,GAAhBD,EAAME,OACL,KAAM,IAAIH,OAAM,gFAOpB,KAHA,GAEIO,GAFAH,EAAS,GAAIC,QAAOJ,EAAM,GAAG,SAASA,EAAM,GAAG,QAAQA,EAAM,GAAI,KACjEK,KAEEC,EAAQH,EAAOK,KAAKX,IACtBQ,EAAOI,KAAKH,EAAM,GAAGI,OAEzB,OAAOL,IASGX,EAAAiB,gBAAd,SAA8BC,EAA+BC,EAA2Bf,GAAA,SAAAA,IAAAA,EAAA,UAS1EJ,EAAAoB,uBAAd,SAAqCC,EAAYC,KAGrDtB,IA5EaC,GAAAD,qBAAoBA,GApB9BA,uBAAAA,0BAmGPuB,OAAAC,QAASxB","file":"recursive-replacement.js","sourcesContent":["\"use strict\";\nvar RecursiveReplacement;\n(function (RecursiveReplacement_1) {\n    /**\n     * A collection of functions that will repeatedly make replacements in a string until no more replacements\n     * can be made\n     */\n    var RecursiveReplacement = (function () {\n        function RecursiveReplacement() {\n        }\n        /**\n         * Does the string contain any delimiters\n         * @param {string} testString The string to checl\n         * @param {string} delimiter Defaults to \"{{ }}\", must have a single space to separate beginning and end\n         * @return {boolean}\n         */\n        RecursiveReplacement.doestStringContainReplacements = function (testString, delimiter) {\n            if (delimiter === void 0) { delimiter = '{{ }}'; }\n            // Check correct parameter usage\n            if ((typeof testString) !== 'string') {\n                throw new Error(\"The first parameter of 'doestStringContainReplacements' must be a string\");\n            }\n            if ((typeof delimiter) !== 'string') {\n                throw new Error(\"The second parameter of 'doestStringContainReplacements' must be a string\");\n            }\n            var parts = delimiter.split(' ');\n            if (parts.length != 2) {\n                throw new Error(\"The second parameter of 'doestStringContainReplacements' must contain a single space\");\n            }\n            // Are there any replacements in this string?\n            // If the delimiter were 'bb dd' this is /bb((.(?!dd))+.)dd/g\n            var regexp = new RegExp(parts[0] + \"((.(?!\" + parts[1] + \"))+.)\" + parts[1], \"g\");\n            var result = testString.match(regexp);\n            return !!result && result.length > 0;\n        };\n        /**\n         * This will check for any replacements using the given delimiter and return an of names. The array will be\n         * empty if there were no replacements found.\n         * @param {string} testString The string to search for replacements\n         * @param {string} delimiter Defaults to \"{{ }}\", must have a single space to separate beginning and end\n         * @return {string[]}\n         */\n        RecursiveReplacement.getReplacementsInString = function (testString, delimiter) {\n            if (delimiter === void 0) { delimiter = '{{ }}'; }\n            // Check correct parameter usage\n            if ((typeof testString) !== 'string') {\n                throw new Error(\"The first parameter of 'getReplacementsInString' must be a string\");\n            }\n            if ((typeof delimiter) !== 'string') {\n                throw new Error(\"The second parameter of 'getReplacementsInString' must be a string\");\n            }\n            var parts = delimiter.split(' ');\n            if (parts.length != 2) {\n                throw new Error(\"The second parameter of 'getReplacementsInString' must contain a single space\");\n            }\n            // If the delimiter were 'bb dd' this is /bb((.(?!dd))+.)dd/g\n            var regexp = new RegExp(parts[0] + \"((.(?!\" + parts[1] + \"))+.)\" + parts[1], \"g\");\n            var result = [];\n            var match;\n            while (match = regexp.exec(testString)) {\n                result.push(match[1].trim());\n            }\n            return result;\n        };\n        /**\n         * This will replace strings\n         * @param {string} stringWithReplacements The string to do the replacements in\n         * @param {string} delimiter Defaults to \"{{ }}\", must have a single space to separate beginning and end\n         * @param replacements\n         */\n        RecursiveReplacement.replaceInString = function (stringWithReplacements, replacements, delimiter) {\n            if (delimiter === void 0) { delimiter = '{{ }}'; }\n        };\n        /**\n         * Get the string value from the recursive data object\n         * @param key\n         * @param replacementData\n         */\n        RecursiveReplacement.getReplacementFromData = function (key, replacementData) {\n        };\n        return RecursiveReplacement;\n    }());\n    RecursiveReplacement_1.RecursiveReplacement = RecursiveReplacement;\n})(RecursiveReplacement || (RecursiveReplacement = {}));\nmodule.exports = RecursiveReplacement;\n","module RecursiveReplacement {\n\n    /**\n     * An array of string keys to either string keys or other arrays\n     */\n    export interface Data {\n        [key:string]:string|Data;\n    }\n\n    /**\n     * An array of string keys to string values\n     */\n    export interface Replacements {\n        [ke:string]:string;\n    }\n\n    /**\n     * A collection of functions that will repeatedly make replacements in a string until no more replacements\n     * can be made\n     */\n    export class RecursiveReplacement {\n\n        /**\n         * Does the string contain any delimiters\n         * @param {string} testString The string to checl\n         * @param {string} delimiter Defaults to \"{{ }}\", must have a single space to separate beginning and end\n         * @return {boolean}\n         */\n        public static doestStringContainReplacements(testString:string, delimiter:string = '{{ }}') {\n            // Check correct parameter usage\n            if((typeof testString) !== 'string') {\n                throw new Error(\"The first parameter of 'doestStringContainReplacements' must be a string\");\n            }\n            if((typeof delimiter) !== 'string') {\n                throw new Error(\"The second parameter of 'doestStringContainReplacements' must be a string\");\n            }\n            let parts = delimiter.split(' ');\n            if(parts.length != 2) {\n                throw new Error(\"The second parameter of 'doestStringContainReplacements' must contain a single space\");\n            }\n\n            // Are there any replacements in this string?\n            // If the delimiter were 'bb dd' this is /bb((.(?!dd))+.)dd/g\n            let regexp = new RegExp(parts[0]+\"((.(?!\"+parts[1]+\"))+.)\"+parts[1], \"g\");\n            let result = testString.match(regexp);\n            return !!result && result.length > 0;\n        }\n\n        /**\n         * This will check for any replacements using the given delimiter and return an of names. The array will be\n         * empty if there were no replacements found.\n         * @param {string} testString The string to search for replacements\n         * @param {string} delimiter Defaults to \"{{ }}\", must have a single space to separate beginning and end\n         * @return {string[]}\n         */\n        public static getReplacementsInString(testString:string, delimiter:string = '{{ }}') {\n            // Check correct parameter usage\n            if((typeof testString) !== 'string') {\n                throw new Error(\"The first parameter of 'getReplacementsInString' must be a string\");\n            }\n            if((typeof delimiter) !== 'string') {\n                throw new Error(\"The second parameter of 'getReplacementsInString' must be a string\");\n            }\n            let parts = delimiter.split(' ');\n            if(parts.length != 2) {\n                throw new Error(\"The second parameter of 'getReplacementsInString' must contain a single space\");\n            }\n\n            // If the delimiter were 'bb dd' this is /bb((.(?!dd))+.)dd/g\n            let regexp = new RegExp(parts[0]+\"((.(?!\"+parts[1]+\"))+.)\"+parts[1], \"g\");\n            let result = [];\n            let match;\n            while(match = regexp.exec(testString)) {\n                result.push(match[1].trim());\n            }\n            return result;\n        }\n\n        /**\n         * This will replace strings\n         * @param {string} stringWithReplacements The string to do the replacements in\n         * @param {string} delimiter Defaults to \"{{ }}\", must have a single space to separate beginning and end\n         * @param replacements\n         */\n        public static replaceInString(stringWithReplacements:string, replacements:Replacements, delimiter:string = '{{ }}') {\n\n        }\n\n        /**\n         * Get the string value from the recursive data object\n         * @param key\n         * @param replacementData\n         */\n        public static getReplacementFromData(key:string, replacementData:Data) {\n\n        }\n    }\n}\n\nexport = RecursiveReplacement;\n"],"sourceRoot":"/source/"}